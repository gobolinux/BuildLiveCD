#!/usr/bin/env python3

# Create a new ISO based on a reference ISO + a set of tarballs.
# Written by Lucas C. Villa Real <lucasvr@gobolinux.org>
# Released under the GNU GPL version 2.

import os
import sys
import time
import shutil
import tarfile
import tempfile
import subprocess
from glob import glob
from datetime import datetime

class MountError(Exception):
    def __init__(self, expression, message):
        self.expression = expression
        self.message = message

class BaseImageFile:
    def mount(self, image_file, mountpoint):
        info = subprocess.run(["mount", "-o", "loop", image_file, mountpoint])
        if info.returncode != 0:
            raise MountError(" ".join(info.args), f"Error mounting {image_file}")

    def unmount(self, mountpoint):
        info = subprocess.run(["umount", mountpoint])
        if info.returncode != 0:
            raise MountError(" ".join(info.args), f"Error unmounting {mountpoint}")

class ISOFile(BaseImageFile):
    def __init__(self, iso_file):
        self.iso_file = iso_file
        self.mountpoint = ""
        self.squashfs_dirs = []
    
    def mount(self, mountpoint):
        self.mountpoint = mountpoint
        return super().mount(self.iso_file, self.mountpoint)

    def unmount(self):
        return super().unmount(self.mountpoint)

    def extractFiles(self, dest_dir):
        if not os.path.exists(f"{dest_dir}/isolinux"):
            subprocess.run(["cp", "-a", f"{self.mountpoint}/isolinux", f"{dest_dir}/isolinux"])

        if os.path.exists(f"{dest_dir}/rootfs"):
            return

        for squash_file in glob(f"{self.mountpoint}/*.squashfs"):
            print("--> Extracting {}".format(os.path.basename(squash_file)))
            squash = SquashFile(squash_file)
            squash_dest_dir = f"{dest_dir}/rootfs"
            try:
                squash.extractFiles(squash_dest_dir)
            except FileExistsError:
                raise

    def create(self, out_dir):
        # Main SquashFS file
        squash = SquashFile(f"{out_dir}/gobolinux-live.squashfs")
        squash.create(glob(f"{out_dir}/rootfs/*"))

        efiboot_file = "isolinux/efiboot.img"
        print("--> Generating ISO file...")
        cmd = [
            "xorrisofs",
            "-R",
            "-b", "isolinux/isolinux.bin",
            "-c", "isolinux/boot.cat",
            "-no-emul-boot",
            "-boot-load-size", "4",
            "-boot-info-table",
            "-input-charset", "utf-8",
            "-eltorito-alt-boot",
            "-eltorito-boot", efiboot_file,
            "-no-emul-boot",
            "-appid", "GoboLinux Live Installer",
            "-V", "GOBOLINUX_LIVE_INSTALLER",
            "-publisher", "GoboLinux.org",
            "-p", "Gobo Himself",
            "-m", f"{out_dir}/{os.path.basename(self.iso_file)}",
            "-m", f"{out_dir}/rootfs",
            "-output", self.iso_file,
            out_dir
        ]
        subprocess.run(cmd)


class SquashFile(BaseImageFile):
    def __init__(self, squash_file):
        self.squash_file = squash_file

    def mount(self, mountpoint):
        self.mountpoint = mountpoint
        return super().mount(self.squash_file, self.mountpoint)

    def unmount(self):
        return super().unmount(self.mountpoint)

    def extractFiles(self, dest_dir):
        cmd = ["unsquashfs", "-f", "-d", dest_dir, self.squash_file]
        subprocess.run(cmd)

    def create(self, src_dirs):
        # TODO: improve rebuild test
        if not os.path.exists(self.squash_file):
            cmd = ["mksquashfs"] + src_dirs + [self.squash_file]
            cmd += ["-comp", "zstd", "-noappend", "-no-sparse", "-keep-as-directory"]
            subprocess.run(cmd)

class BinaryPackage:
    def __init__(self, package_file):
        self.package_file = package_file

    def programName(self):
        return os.path.basename(self.package_file).split("--")[0]

    def programVersion(self):
        full_version = os.path.basename(self.package_file).split("--")[1]
        revision = full_version.rfind("-r")
        version = full_version if revision == -1 else full_version[:revision]
        return version

    def priorVersion(self, programs_dir):
        path = f"{programs_dir}/{self.programName()}"
        versions = glob(f"{path}/*")
        for ignore_version in ["Current", "Variable", "Settings"]:
            try:
                versions.remove(ignore_version)
            except ValueError:
                pass
        if len(versions) != 1:
            print(f"Warning: more than one version exists at {path}")
        return sorted(versions)[0]

    def merge(self, squashfs_dir):
        name, version = self.programName(), self.programVersion()
        programs_dir = f"{squashfs_dir}/Programs"
        current_symlink = f"{programs_dir}/{name}/Current"

        new_path = f"{programs_dir}/{name}/{version}"
        old_path = sorted(glob(f"{programs_dir}/{name}/*"))
        old_path = old_path[0] if len(old_path) > 0 else None

        if os.path.exists(new_path):
            path_timestamp = os.stat(new_path).st_ctime
            package_timestamp = os.stat(self.package_file).st_ctime
            if path_timestamp < package_timestamp:
                print(f"Replacing outdated program {name}")
                shutil.rmtree(new_path)
                self.__uncompressAndLink(programs_dir, new_path, current_symlink)
            else:
                print(f"Keeping existing program {name}")
        elif old_path is not None:
            print(f"Replacing outdated program {name}")
            shutil.rmtree(old_path)
            self.__uncompressAndLink(programs_dir, new_path, current_symlink)
        elif old_path is None:
            print(f"Adding program {name}")
            self.__uncompressAndLink(programs_dir, new_path, current_symlink)

    def __uncompressAndLink(self, programs_dir, new_path, current_symlink):
        with tarfile.open(self.package_file, "r:bz2") as tar:
            tar.extractall(programs_dir)

        if os.path.lexists(current_symlink):
            os.unlink(current_symlink)
        new_version = os.path.basename(new_path)
        os.symlink(new_version, current_symlink)

        # Update new_path's last access and modification times
        now = time.mktime(datetime.now().timetuple())
        os.utime(new_path, (now, now))

class ISOLinux:
    def __init__(self, path):
        self.path = path
        self.old_kernel_path = f"{self.path}/kernel"

    def updateKernel(self, new_kernel_path):
        old_timestamp = os.stat(self.old_kernel_path).st_mtime
        new_timestamp = os.stat(os.path.realpath(new_kernel_path)).st_mtime
        if old_timestamp < new_timestamp:
            print("--> Updating ISOLINUX kernel file")
            os.unlink(self.old_kernel_path)
            shutil.copy2(new_kernel_path, self.old_kernel_path)

def main():
    if len(sys.argv) < 3:
        print(f"Syntax: {sys.argv[0]} <iso_file> <work_directory> [packages_directory]")
        sys.exit(1)

    iso_file = os.path.realpath(sys.argv[1])
    work_dir = os.path.realpath(sys.argv[2])
    packages_dir = os.path.realpath(sys.argv[3]) if len(sys.argv) == 4 else None
    os.makedirs(work_dir, exist_ok=True)

    if packages_dir is not None and not os.path.exists(packages_dir):
        print(f"Error: packages directory '{packages_dir}' does not exist")
        sys.exit(1)

    # Extract isolinux and squashfs files from the original ISO
    with tempfile.TemporaryDirectory() as iso_mountpoint:
        iso = ISOFile(iso_file)
        iso.mount(iso_mountpoint)
        try:
            iso.extractFiles(work_dir)
        finally:
            iso.unmount()

    # Extract tarballs
    if packages_dir is not None:
        print("--> Processing tarballs")
        for path in glob(f"{packages_dir}/*.bz2"):
            p = BinaryPackage(path)
            p.merge(f"{work_dir}/rootfs")

    # Update kernel image used by the Live environment
    kernel_path = "/Programs/Linux/Current/Resources/Unmanaged/System/Kernel/Boot/kernel"
    bootloader = ISOLinux(f"{work_dir}/isolinux")
    bootloader.updateKernel(f"{work_dir}/rootfs/{kernel_path}")

    new_iso = ISOFile(f"{work_dir}/gobolinux.iso")
    new_iso.create(work_dir)

if __name__ == "__main__":
    main()
