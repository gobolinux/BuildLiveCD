#!/usr/bin/env python3

# Create a new ISO based on a reference ISO + a set of tarballs.
# Written by Lucas C. Villa Real <lucasvr@gobolinux.org>
# Released under the GNU GPL version 2.

import os
import sys
import time
import shutil
import tarfile
import tempfile
import subprocess
from glob import glob
from datetime import datetime

class MountError(Exception):
    def __init__(self, expression, message):
        self.expression = expression
        self.message = message

class BaseImageFile:
    def mount(self, image_file, mountpoint):
        info = subprocess.run(["mount", "-o", "loop", image_file, mountpoint])
        if info.returncode != 0:
            raise MountError(" ".join(info.args), f"Error mounting {image_file}")

    def unmount(self, mountpoint):
        info = subprocess.run(["umount", mountpoint])
        if info.returncode != 0:
            raise MountError(" ".join(info.args), f"Error unmounting {mountpoint}")

class ISOFile(BaseImageFile):
    def __init__(self, iso_file):
        self.iso_file = iso_file
        self.mountpoint = ""
        self.squashfs_dirs = []
    
    def mount(self, mountpoint):
        self.mountpoint = mountpoint
        return super().mount(self.iso_file, self.mountpoint)

    def unmount(self):
        return super().unmount(self.mountpoint)

    def extractFiles(self, dest_dir):
        if not os.path.exists(f"{dest_dir}/isolinux"):
            subprocess.run(["cp", "-a", f"{self.mountpoint}/isolinux", f"{dest_dir}/isolinux"])

        if os.path.exists(f"{dest_dir}/rootfs"):
            return

        for squash_file in glob(f"{self.mountpoint}/*.squashfs"):
            print("--> Extracting {}".format(os.path.basename(squash_file)))
            squash = SquashFile(squash_file)
            squash_dest_dir = f"{dest_dir}/rootfs"
            try:
                squash.extractFiles(squash_dest_dir)
            except FileExistsError:
                raise

    def create(self, out_dir):
        # Main SquashFS file
        squash = SquashFile(f"{out_dir}/gobolinux-live.squashfs")
        squash.create(glob(f"{out_dir}/rootfs/*"))

        efiboot_file = "isolinux/efiboot.img"
        print("--> Generating ISO file...")
        cmd = [
            "xorrisofs",
            "-R",
            "-b", "isolinux/isolinux.bin",
            "-c", "isolinux/boot.cat",
            "-no-emul-boot",
            "-boot-load-size", "4",
            "-boot-info-table",
            "-input-charset", "utf-8",
            "-eltorito-alt-boot",
            "-eltorito-boot", efiboot_file,
            "-no-emul-boot",
            "-appid", "GoboLinux Live Installer",
            "-V", "GOBOLINUX_LIVE_INSTALLER",
            "-publisher", "GoboLinux.org",
            "-p", "Gobo Himself",
            "-m", f"{out_dir}/{os.path.basename(self.iso_file)}",
            "-m", f"{out_dir}/rootfs",
            "-output", self.iso_file,
            out_dir
        ]
        subprocess.run(cmd)


class SquashFile(BaseImageFile):
    def __init__(self, squash_file):
        self.squash_file = squash_file

    def mount(self, mountpoint):
        self.mountpoint = mountpoint
        return super().mount(self.squash_file, self.mountpoint)

    def unmount(self):
        return super().unmount(self.mountpoint)

    def extractFiles(self, dest_dir):
        cmd = ["unsquashfs", "-f", "-d", dest_dir, self.squash_file]
        subprocess.run(cmd)

    def create(self, src_dirs):
        # TODO: improve rebuild test
        if not os.path.exists(self.squash_file):
            cmd = ["mksquashfs"] + src_dirs + [self.squash_file]
            cmd += ["-comp", "zstd", "-noappend", "-no-sparse", "-keep-as-directory"]
            subprocess.run(cmd)

class BinaryPackage:
    def __init__(self, package_file):
        self.package_file = package_file

    def programName(self):
        return os.path.basename(self.package_file).split("--")[0]

    def programVersion(self):
        full_version = os.path.basename(self.package_file).split("--")[1]
        revision = full_version.rfind("-r")
        version = full_version if revision == -1 else full_version[:revision]
        return version

    def priorVersion(self, programs_dir):
        path = f"{programs_dir}/{self.programName()}"
        versions = glob(f"{path}/*")
        for ignore_version in ["Current", "Variable", "Settings"]:
            try:
                versions.remove(ignore_version)
            except ValueError:
                pass
        if len(versions) != 1:
            print(f"Warning: more than one version exists at {path}")
        return sorted(versions)[0]

    def merge(self, squashfs_dir):
        name, version = self.programName(), self.programVersion()
        programs_dir = f"{squashfs_dir}/Programs"
        current_symlink = f"{programs_dir}/{name}/Current"

        new_path = f"{programs_dir}/{name}/{version}"
        old_path = sorted(glob(f"{programs_dir}/{name}/*"))
        old_path = old_path[0] if len(old_path) > 0 else None

        if os.path.exists(new_path):
            path_timestamp = os.stat(new_path).st_ctime
            package_timestamp = os.stat(self.package_file).st_ctime
            if path_timestamp < package_timestamp:
                print(f"Replacing outdated program {name}")
                removed = self.__removeProgram(new_path)
                self.__uncompressAndLink(programs_dir, new_path, current_symlink)
                self.__removeBrokenLinks(squashfs_dir, removed)
            else:
                print(f"Keeping existing program {name}")
        elif old_path is not None:
            print(f"Replacing outdated program {name}")
            removed = self.__removeProgram(old_path)
            self.__uncompressAndLink(programs_dir, new_path, current_symlink)
            self.__removeBrokenLinks(squashfs_dir, removed)
        elif old_path is None:
            print(f"Adding program {name}")
            self.__uncompressAndLink(programs_dir, new_path, current_symlink)

    def __removeProgram(self, path):
        # Remove directory tree
        removed_files = [x.replace(path, "")[1:] for x in glob(f"{path}/**", recursive=True)]
        shutil.rmtree(path)
        return removed_files

    def __removeBrokenLinks(self, squashfs_dir, removed_files):
        broken_list = []
        for path in removed_files:
            # Was this file likely linked to /System/Index?
            for system_index_dir in ["bin", "include", "lib", "libexec", "share"]:
                if path.startswith(system_index_dir):
                    broken_list.append(path)
                    break
        # Prevent the argument list from growing too long. We should, ideally, check
        # the output of `getconf ARG_MAX` and split the list according to the number
        # of bytes needed to represent its members, but using a predefined chunk size
        # of 10k file names should work for the most common use cases.
        chroot = InChroot(squashfs_dir)
        for chunk in self.__splitList(broken_list, 10000):
            chroot.exec(["/bin/RemoveBroken"] + chunk)

    def __splitList(self, the_list, n):
        for i in range(0, len(the_list), n):
            yield the_list[i:i+n]

    def __uncompressAndLink(self, programs_dir, new_path, current_symlink):
        with tarfile.open(self.package_file, "r:bz2") as tar:
            tar.extractall(programs_dir)

        # Symlink program
        squashfs_dir = os.path.dirname(programs_dir)
        program_dir = new_path.replace(squashfs_dir, "")
        chroot = InChroot(squashfs_dir)
        chroot.symlink(program_dir)

        # Update "Current" symlink
        if os.path.lexists(current_symlink):
            os.unlink(current_symlink)
        new_version = os.path.basename(new_path)
        os.symlink(new_version, current_symlink)

        # Update new_path's last access and modification times
        now = time.mktime(datetime.now().timetuple())
        os.utime(new_path, (now, now))

class ISOLinux:
    def __init__(self, path):
        self.path = path
        self.old_kernel_path = f"{self.path}/kernel"

    def updateKernel(self, new_kernel_path):
        old_timestamp = os.stat(self.old_kernel_path).st_mtime
        new_timestamp = os.stat(os.path.realpath(new_kernel_path)).st_mtime
        if old_timestamp < new_timestamp:
            print("--> Updating ISOLINUX kernel file")
            os.unlink(self.old_kernel_path)
            shutil.copy2(new_kernel_path, self.old_kernel_path)

class InChroot:
    def __init__(self, squashfs_dir):
        self.directory_stack = []
        self.squashfs_dir = squashfs_dir
        self.overwrite = "--overwrite"
        self.relative  = "" # "--relative"
        self.no_follow = "" # "--no-follow"

    def symlink(self, program_version_path):
        goboPrefix = self.squashfs_dir
        goboIndex = f"{goboPrefix}/System/Index"
        goboExecutables = f"{goboIndex}/bin"
        goboLibraries = f"{goboIndex}/lib"
        goboHeaders = f"{goboIndex}/include"

        # Symlink essential directories, then chroot into target and
        # perform the complete linking process through SymlinkProgram.
        symlink_map = {
            f"{program_version_path}/lib": goboLibraries,
            f"{program_version_path}/bin": goboExecutables,
            f"{program_version_path}/sbin": goboExecutables,
            f"{program_version_path}/include": goboHeaders,
        }
        for source, target in symlink_map.items():
            self.__linkDirectory(source, target)

        # Chroot and SymlinkProgram
        program = program_version_path.split("/")[1]
        version = program_version_path.split("/")[2]
        self.exec(["/bin/SymlinkProgram", "-c", "overwrite", program, version])

    def exec(self, cmd):
        try:
            subprocess.run(["mount", "-o", "bind", "/dev", f"{self.squashfs_dir}/dev"])
            subprocess.run(["mount", "-o", "bind", "/proc", f"{self.squashfs_dir}/proc"])
            subprocess.run(["chroot", self.squashfs_dir] + cmd)
        finally:
            subprocess.run(["umount", f"{self.squashfs_dir}/dev"])
            subprocess.run(["umount", f"{self.squashfs_dir}/proc"])

    def __linkDirectory(self, from_path, to_path):
        rfrom = os.path.realpath(from_path)
        if not self.__isEmptyDirectory(rfrom):
            here = os.path.realpath(to_path)
            if not os.path.exists(here):
                # It is unlikely that e.g., /System/Index/bin does not exist, but
                # we treat the situation anyhow.
                os.makedirs(here)

            with open("/dev/null", "w") as devnull:
                env = {}
                for name in ["debugFD", "verboseFD", "terseFD", "errorFD", "normalFD"]:
                    env[name] = "2"
                env["scriptName"] = "RefreshLiveCD"
                env["goboPrograms"] = "/Programs"
                env["goboPrefix"] = self.squashfs_dir

                self.__pushd(here)
                cmd = ["/bin/LinkOrExpandAll", rfrom, self.overwrite, self.relative, self.no_follow]
                subprocess.run(cmd, env=env, stderr=devnull)
                self.__popd()
        else:
            try:
                os.unlink(rfrom)
            except:
                pass

    def __pushd(self, path):
        self.directory_stack.append(os.getcwd())
        os.chdir(path)

    def __popd(self):
        old_path = self.directory_stack.pop(-1)
        os.chdir(old_path)

    def __isEmptyDirectory(self, path):
        return len(glob(f"{path}/*")) == 0

def main():
    if len(sys.argv) < 3:
        print(f"Syntax: {sys.argv[0]} <iso_file> <work_directory> [packages_directory]")
        sys.exit(1)

    iso_file = os.path.realpath(sys.argv[1])
    work_dir = os.path.realpath(sys.argv[2])
    packages_dir = os.path.realpath(sys.argv[3]) if len(sys.argv) == 4 else None
    os.makedirs(work_dir, exist_ok=True)

    if packages_dir is not None and not os.path.exists(packages_dir):
        print(f"Error: packages directory '{packages_dir}' does not exist")
        sys.exit(1)

    # Extract isolinux and squashfs files from the original ISO
    with tempfile.TemporaryDirectory() as iso_mountpoint:
        iso = ISOFile(iso_file)
        iso.mount(iso_mountpoint)
        try:
            iso.extractFiles(work_dir)
        finally:
            iso.unmount()

    # Extract tarballs
    if packages_dir is not None:
        print("--> Processing tarballs")
        for path in glob(f"{packages_dir}/*.bz2"):
            p = BinaryPackage(path)
            p.merge(f"{work_dir}/rootfs")

    # Update kernel image used by the Live environment
    kernel_path = "/Programs/Linux/Current/Resources/Unmanaged/System/Kernel/Boot/kernel"
    bootloader = ISOLinux(f"{work_dir}/isolinux")
    bootloader.updateKernel(f"{work_dir}/rootfs/{kernel_path}")

    new_iso = ISOFile(f"{work_dir}/gobolinux.iso")
    new_iso.create(work_dir)

if __name__ == "__main__":
    main()
