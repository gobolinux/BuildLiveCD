#!/bin/bash

source $(dirname $0)/CompatFunctions

helpOnNoArguments=yes
scriptDescription="Automated program compilation tool."
scriptCredits="(C)2003-2009 by Hisham Muhammad et al. Released under the GNU GPL."
scriptUsage="<program> <options> -- <packagelist1> [packagelist2] ..."

Add_Option_Entry "r" "root" "Root directory to populate."
Add_Option_Entry "p" "packagedir" "Directory containing the binary packages."
Add_Option_Boolean "i" "use-system-index" "Generate a tree using the /System/Index layout."
Parse_Options "$@"

# Extra arguments go to the packagelist array
eval `Args_To_Array packagelist $@`

unset root
unset packagedir
unset usesystemindex

Is_Entry "root" && root=`Entry "root"`
Is_Entry "packagedir" && packagedir=`Entry "packagedir"`
Boolean "use-system-index" && usesystemindex=true

# Sanity checks
[ -z "$root" ] && Die "root option must be set."
[ -z "$packagedir" ] && Die "packagedir option must be set."
[ -d "$packagedir" ] || Die "$packagedir does not exist"
[ -z "$packagelist" ] && Die "packagelist option must be set."
for list in ${packagelist[@]}
do
   [ -f "$list" ] || Die "$list does not exist"
done

datadir="${goboPrograms}/BuildLiveCD/Current/Data"

Verify_Superuser

function get_package_name() {
   packagename=`echo $1 | awk {'print $1'} | grep -v "^#"`

   if [ -e "$datadir/Packages-List-GoboLinuxTools-Git" ] && grep -q "$packagename" "$datadir/Packages-List-GoboLinuxTools-Git"
   then packagever=`date +%Y%m%d`
   else packagever=`echo $1 | awk {'print $2'} | grep -v "^#"`
   fi
   pkg=`ls $packagedir/${packagename}--${packagever}--* 2> /dev/null || true`
   [ -z "$pkg" ] && pkg=`ls $packagedir/${packagename}--* 2> /dev/null || true`
   if [ -z "$pkg" ]
   then
      Die "*** Package $packagename $packagever could not be filled. ***" 
   fi
   if [ "`ls $packagedir/${packagename}--* | wc -l 2> /dev/null`" -gt 1 ]
   then  
      Log_Terse "*** Warning: more than one version for $packagename available. ***"
   fi

   echo "$pkg"
}

for list in ${packagelist[@]}
do
   cat $list | while read line
   do
      # just ensure that required packages are found
      ret=`echo "$line" | awk {'print $1'}`
      [ -z "$ret" ] || echo $ret | grep -q "^#" && continue
      get_package_name "$line" > /dev/null || exit 1
   done
done

[ $? -eq 0 ] || exit 1

function unpack_scripts() {
   local scripts_package=$(get_package_name Scripts)
   local compile_package=$(get_package_name Compile)
   if [ ! -d /tmp/Scripts ]
   then
      Quiet pushd /tmp
      tar xjpf "$scripts_package"
      tar xjpf "$compile_package"
      Quiet popd

      # Prepare the Scripts package so we can symlink programs
      GrepReplace 'conflocations=(' \
                  'conflocations=( "$(dirname $scriptPath)/Resources/Defaults/Settings/Scripts"' \
                  $(scripts_dir)/Functions/GoboLinux
      make -C $(scripts_dir)/src
      mv $(compile_dir)/bin/PrepareProgram $(scripts_dir)/bin
      rm -rf /tmp/Compile
   fi
}

function remove_unpacked_scripts() {
   rm -rf /tmp/Scripts
}

function scripts_dir() {
   echo /tmp/Scripts/*
}

function compile_dir() {
   echo /tmp/Compile/*
}

function do_link() {
   if [ -d "$root/$1" ]
   then
      pushd $root/$2 &>/dev/null
      (
         export verboseFD=100
         export normalFD=101
         export terseFD=102
         export errorFD=103
         export debugFD=104
         export logFD=105
         export questionFD=106
         eval "exec $verboseFD>/dev/null"
         eval "exec $normalFD>/dev/null"
         eval "exec $terseFD<&2"
         eval "exec $errorFD<&2"
         eval "exec $debugFD>/dev/null"
         eval "exec $logFD>/dev/null"

         export goboPrefix=$root
         export goboPrograms=$root/Programs 
         $(scripts_dir)/bin/LinkOrExpandAll $root/$1 --relative --no-follow
      )
      popd &>/dev/null
   fi
}


function symlink_program() {
   full_path="$1"
   root=`readlink -f $2`
   gobosystem=/System
   gobolinks=${gobosystem}/Links
   goboindex=/usr
   name=$(basename $(dirname $full_path))
   version=$(basename ${full_path})
   
   if [ "$usesystemindex" ]
   then
      goboenvironment=${gobosystem}/Environment
      do_link ${full_path}/bin ${goboindex}/bin
      do_link ${full_path}/sbin ${goboindex}/bin
      do_link ${full_path}/Resources/Wrappers ${goboindex}/bin
      do_link ${full_path}/Resources/Tasks ${gobosystem}/Tasks
      do_link ${full_path}/lib ${goboindex}/lib
      do_link ${full_path}/libexec ${goboindex}/libexec
      #do_link ${full_path}/lib64 ${goboindex}/lib64
      do_link ${full_path}/man ${goboindex}/share/man
      do_link ${full_path}/info ${goboindex}/share/info
      do_link ${full_path}/include ${goboindex}/include
      do_link ${full_path}/../Settings ${gobosystem}/Settings
      do_link ${full_path}/share ${goboindex}/share

      [ -f "${root}${full_path}/Resources/Environment" ] && \
      ln -nfs ../../Programs/${name}/${version}/Resources/Environment ${root}${goboenvironment}/${name}--${version}
      ln -nfs $version ${root}$(dirname ${full_path})/Current
   else
      goboenvironment=${gobolinks}/Environment
      do_link ${full_path}/bin ${gobolinks}/Executables
      do_link ${full_path}/sbin ${gobolinks}/Executables
      do_link ${full_path}/Resources/Wrappers ${gobolinks}/Executables
      do_link ${full_path}/Resources/Tasks ${gobolinks}/Tasks
      do_link ${full_path}/lib ${gobolinks}/Libraries
      do_link ${full_path}/man ${gobolinks}/Manuals
      do_link ${full_path}/info ${gobolinks}/Manuals/info
      do_link ${full_path}/include ${gobolinks}/Headers
      do_link ${full_path}/../Settings ${gobolinks}/../Settings
      do_link ${full_path}/Shared ${gobolinks}/Shared

      [ -f "${root}${full_path}/Resources/Environment" ] && \
      ln -nfs ../../../Programs/${name}/${version}/Resources/Environment ${root}${goboenvironment}/${name}--${version}
      ln -nfs $version ${root}$(dirname ${full_path})/Current
   fi

}

function program_md5() {
   name="$1"
   version="$2"
   cat "${root}"/../Checksums/$name--$version 2> /dev/null | tail -1 || echo "0000"
}

function install_package() {
   package=`readlink -f "$1"`
   root="$2"
   base=$(basename $package)
   name=${base%%--*}
   packageversion=${base#*--}
   version=`echo ${packageversion%%--*} | sed -r 's/-r[0-9]+(p[0-9]+)?$//g'`
   if [ "$usesystemindex" ]
   then vardir=/Data/Variable
   else vardir=/System/Variable
   fi
   
   packagemd5=`md5sum $package`
   if [ -d "$root/Programs/$name" ]
   then 
      if [ "`program_md5 $name $version`" =  "$packagemd5" ]
      then
         Log_Normal "Keeping $name $version..."
         if [ ! -e "$root/Programs/$name/Current" ]
         then
            # Create missing symlink
            ln -nfs $version $root/Programs/$name/Current
         fi

         # just keep package: md5 matches last installation
         return
      else
         Log_Normal "Removing existing $name $version..."

         # cleanup old md5 file
         rm -f "${root}"/../Checksums/$name--$packageversion*
         # remove the installed package: $package was updated 
         rm -rf "$root/Programs/$name/$version"
         rm -rf "$root/Programs/$name/Settings"
         rmdir  "$root/Programs/$name/" >& /dev/null
      fi
   fi
   echo "$packagemd5" > "${root}"/../Checksums/$name--$version
   
   Log_Normal "Installing $name $version..."
   pushd "$root/Programs" &> /dev/null
   tar xjpf "$package"

   # Remove empty dirs in Resources
   for i in `find "$name/$version/Resources" -type d -empty 2> /dev/null | grep -v Variable | grep -v Settings`
   do
       rmdir -p $i 2> /dev/null || true
   done
   
   if [ ! "$usesystemindex" ]
   then
      # Fixes broken share->Shared instead of share->/System/Links/Shared
      lshare="$name/$version/share"
      [ -h "$lshare" ] && ln -nfs /System/Links/Shared "$lshare"
   fi

   dsettings="$name/$version/Resources/Defaults/Settings"
   [ -d "$dsettings" ] && cp -a "$dsettings" "$name/Settings"
   dvariable="$name/$version/Resources/Defaults/Variable"
   if [ -d "$dvariable" ]
   then
      cp -rf "$dvariable"/* $vardir
      ln -s $vardir "$name/Variable"
   fi
   
   # Handling Unmanaged files (emulating InstallPackage)
   # This is now handled by unionfs in InitRDScripts/bin/startGoboLinux
   #if [ -d "$name/$version/Resources/Unmanaged/" -a "$name" != "Linux" ]
   #then
   #   cp -fa $name/$version/Resources/Unmanaged/* ../ # warning: assuming we are under $root/Programs
   #fi
   
   popd &> /dev/null
   
   symlink_program /Programs/$name/$version $root
}

Log_Normal "BuildRoot: Building root $root..."

#
# Base Directories
#
unpack_scripts
source $(scripts_dir)/Functions/Bootstrap
Create_Filesystem_Tree $root 0 $usesystemindex
Create_Device_Nodes $root

#
# Checksum generation
#
mkdir -p "${root}"/../Checksums/

mksettings=`which MakeSystemSettings`
if [ "`md5sum "$mksettings"`" =  "`cat "${root}/../Checksums/MakeSystemSettings" 2> /dev/null`" ]
then
   Log_Normal "Skipping MakeSystemSettings"
else
   Log_Normal "Running MakeSystemSettings"
   rm -f "${root}"/../Checksums/$name--*
   pushd $root/System/Settings &> /dev/null
   # MakeSystemSettings overwrites existing files
   MakeSystemSettings
   popd &> /dev/null
   md5sum "$mksettings" > "${root}/../Checksums/MakeSystemSettings"
fi

for list in ${packagelist[@]}
do
   Log_Terse "Installing packages from $list"
   cat $list | while read line
   do
      name=$(echo $line | awk {'print $1'})
      version=$(echo $line | awk {'print $2'})
      if [ -z "$name" ] || echo "$name" | grep -q "^#"
      then continue
      fi
      if echo "${version:0:1}" | grep -q "^#"
      then unset version
      fi
      pkgs=(`get_package_name $line`)
      for pkg in ${pkgs[@]}; do install_package "$pkg" "$root"; done
   done
done

if [ "$usesystemindex" ]
then goboenvironment="/System/Environment"
else goboenvironment="/System/Links/Environment"
fi
cachefile=${goboenvironment}/Cache
if [ ! -e "${root}${cachefile}" -o "`find "${root}${goboenvironment}/" -newer "${root}${cachefile}" 2> /dev/null`" ] 
then
   echo "Updating ${root}${cachefile}..."
   echo -e "unset unsetvars\n[ ! \"\$goboSettings\" ] && unsetvars=true\n\nsource GoboPath\n" > ${root}${cachefile}
   for link in ${root}${goboenvironment}/*--*
   do
      if [ -e ${link} ] 
      then
         cat ${link} >> ${root}${cachefile} || rm -f ${link}
         echo >> ${root}${cachefile}
      fi
   done
   unsetvars=(goboUserSettings goboUsers goboMount goboPrograms goboSystem goboScripts goboIndex goboManuals
              goboLinks goboExecutables goboLibraries goboHeaders goboShared goboVariable goboSettings goboKernel
              goboTasks goboEnvironment goboTemp goboBoot goboDevices goboStatus goboObjects
              goboModules goboInstall)

   echo -e "if [ \"\$unsetvars\" ]\nthen" >> ${root}${cachefile}
   for var in "${unsetvars[@]}"
   do
       echo "  unset $var" >> ${root}${cachefile} 
   done
   echo -e "fi\n" >> ${root}${cachefile}
else
   echo "Keeping ${root}${goboenvironment}/Cache"
fi

Log_Normal "Running ldconfig"
ldconfig -r ${root}

# SymlinkProgram --relative is not perfect yet, but, ideally, we should call the following command
if [ "$usesystemindex" ]
then
   Log_Normal "Checking for broken links at ${root}/System/Index"
   find ${root}/System/Index/ | $(scripts_dir)/bin/RemoveBroken
else
   Log_Normal "Checking for broken links at ${root}/System/Links/"
   find ${root}/System/Links/ | $(scripts_dir)/bin/RemoveBroken
fi
remove_unpacked_scripts
exit 0
